/**
 * Tests for Config Generator
 *
 * Tests CONFIG--T03: Add Config Generation Command
 */

import { constants } from 'node:fs'
import { access, readFile, unlink } from 'node:fs/promises'

import yaml from 'js-yaml'
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'

import {
	configFileExists,
	generateConfigContent,
	generateConfigFile,
	getDefaultConfigPath,
	validateGeneratedConfig,
} from '../generator.js'

import type { ConfigFormat } from '../schema.js'

describe('Config Generator (CONFIG--T03)', () => {
	// Test file paths
	const testYamlPath = './test-config.yaml'
	const testJsonPath = './test-config.json'

	// Cleanup after each test
	afterEach(async () => {
		// Remove test files
		for (const path of [testYamlPath, testJsonPath]) {
			try {
				await unlink(path)
			} catch {
				// File might not exist, ignore
			}
		}
	})

	// ============================================================================
	// CONFIG-T03-AC02: Format Selection
	// ============================================================================

	describe('CONFIG-T03-AC02: Format selection (--format json|yaml)', () => {
		it('generates YAML content by default', () => {
			const content = generateConfigContent('yaml')

			expect(content).toBeDefined()
			expect(content).toContain('# iMessage Timeline Configuration')
			expect(content).toContain('version: "1.0"')
			expect(content).toContain('attachmentRoots:')
			expect(content).toContain('gemini:')
			expect(content).toContain('enrichment:')
			expect(content).toContain('render:')
		})

		it('generates JSON content when requested', () => {
			const content = generateConfigContent('json')

			expect(content).toBeDefined()
			expect(content).toContain('"version": "1.0"')
			expect(content).toContain('"attachmentRoots"')
			expect(content).toContain('"gemini"')
			expect(content).toContain('"enrichment"')
			expect(content).toContain('"render"')

			// Should be valid JSON
			expect(() => JSON.parse(content)).not.toThrow()
		})

		it('generates parseable YAML content', () => {
			const content = generateConfigContent('yaml')

			// Should be valid YAML
			expect(() => yaml.load(content)).not.toThrow()

			const parsed = yaml.load(content) as any
			expect(parsed).toMatchObject({
				version: '1.0',
				gemini: expect.objectContaining({
					apiKey: '${GEMINI_API_KEY}',
					model: 'gemini-1.5-pro',
				}),
			})
		})

		it('uses correct default file paths', () => {
			expect(getDefaultConfigPath('yaml')).toBe('./imessage-config.yaml')
			expect(getDefaultConfigPath('json')).toBe('./imessage-config.json')
		})
	})

	// ============================================================================
	// CONFIG-T03-AC03: Documentation Comments
	// ============================================================================

	describe('CONFIG-T03-AC03: Documentation comments explaining options', () => {
		it('includes comprehensive YAML comments', () => {
			const content = generateConfigContent('yaml')

			// Check for section headers
			expect(content).toContain('# Attachment Resolution')
			expect(content).toContain('# Gemini AI Configuration')
			expect(content).toContain('# Enrichment Pipeline Configuration')
			expect(content).toContain('# Markdown Rendering Configuration')

			// Check for field explanations
			expect(content).toContain('# Google Gemini API key')
			expect(content).toContain('# Get your key from:')
			expect(content).toContain('# Delay between API calls')
			expect(content).toContain('# Enable image analysis')
			expect(content).toContain('# Maximum nesting depth')
		})

		it('includes documentation in JSON format', () => {
			const content = generateConfigContent('json')

			expect(content).toContain('"_comment"')
			expect(content).toContain('"_generated"')
			expect(content).toContain('Generated by: imessage-timeline init')
		})

		it('explains environment variable usage', () => {
			const content = generateConfigContent('yaml')

			expect(content).toContain('${GEMINI_API_KEY}')
			expect(content).toContain('Environment variable')
		})

		it('documents default values', () => {
			const content = generateConfigContent('yaml')

			expect(content).toContain('Default: 1000')
			expect(content).toContain('Default: 3')
			expect(content).toContain('Default: true')
			expect(content).toContain('Default: 10')
		})

		it('includes range constraints for numeric fields', () => {
			const content = generateConfigContent('yaml')

			expect(content).toContain('Range: 0-10') // maxRetries
			expect(content).toContain('Range: 1-10000') // checkpointInterval
			expect(content).toContain('Range: 1-100') // maxNestingDepth
		})
	})

	// ============================================================================
	// CONFIG-T03-AC01: Init Command
	// ============================================================================

	describe('CONFIG-T03-AC01: init command generates config file', () => {
		it('creates YAML config file successfully', async () => {
			const result = await generateConfigFile({
				filePath: testYamlPath,
				format: 'yaml',
			})

			expect(result.success).toBe(true)
			expect(result.message).toContain('Generated YAML config')
			expect(result.filePath).toBe(testYamlPath)

			// Verify file exists
			const exists = await configFileExists(testYamlPath)
			expect(exists).toBe(true)

			// Verify content
			const content = await readFile(testYamlPath, 'utf-8')
			expect(content).toContain('version: "1.0"')
		})

		it('creates JSON config file successfully', async () => {
			const result = await generateConfigFile({
				filePath: testJsonPath,
				format: 'json',
			})

			expect(result.success).toBe(true)
			expect(result.message).toContain('Generated JSON config')
			expect(result.filePath).toBe(testJsonPath)

			// Verify file exists
			const exists = await configFileExists(testJsonPath)
			expect(exists).toBe(true)

			// Verify content
			const content = await readFile(testJsonPath, 'utf-8')
			const parsed = JSON.parse(content)
			expect(parsed.version).toBe('1.0')
		})
	})

	// ============================================================================
	// CONFIG-T03-AC04: Overwrite Detection
	// ============================================================================

	describe('CONFIG-T03-AC04: Detect existing config and prevent overwrite', () => {
		it('detects non-existent file', async () => {
			const exists = await configFileExists('./does-not-exist.yaml')
			expect(exists).toBe(false)
		})

		it('detects existing file', async () => {
			// Create test file first
			await generateConfigFile({
				filePath: testYamlPath,
				format: 'yaml',
			})

			const exists = await configFileExists(testYamlPath)
			expect(exists).toBe(true)
		})

		it('prevents overwriting existing file without force flag', async () => {
			// Create file first
			await generateConfigFile({
				filePath: testYamlPath,
				format: 'yaml',
			})

			// Try to create again without force
			const result = await generateConfigFile({
				filePath: testYamlPath,
				format: 'yaml',
				force: false,
			})

			expect(result.success).toBe(false)
			expect(result.message).toContain('already exists')
			expect(result.message).toContain('--force')
		})

		it('allows overwriting with force flag', async () => {
			// Create file first
			await generateConfigFile({
				filePath: testYamlPath,
				format: 'yaml',
			})

			// Overwrite with force
			const result = await generateConfigFile({
				filePath: testYamlPath,
				format: 'yaml',
				force: true,
			})

			expect(result.success).toBe(true)
			expect(result.message).toContain('Generated YAML config')
		})
	})

	// ============================================================================
	// CONFIG-T03-AC05: Validate Generated Config
	// ============================================================================

	describe('CONFIG-T03-AC05: Validate generated config against schema', () => {
		it('validates YAML content structure', () => {
			const content = generateConfigContent('yaml')
			const parsed = yaml.load(content) as any

			// Check required top-level fields
			expect(parsed).toHaveProperty('version')
			expect(parsed).toHaveProperty('attachmentRoots')
			expect(parsed).toHaveProperty('gemini')
			expect(parsed).toHaveProperty('enrichment')
			expect(parsed).toHaveProperty('render')

			// Check nested structures
			expect(parsed.gemini).toHaveProperty('apiKey')
			expect(parsed.gemini).toHaveProperty('model')
			expect(parsed.gemini).toHaveProperty('rateLimitDelay')
			expect(parsed.gemini).toHaveProperty('maxRetries')

			expect(parsed.enrichment).toHaveProperty('enableVisionAnalysis')
			expect(parsed.enrichment).toHaveProperty('checkpointInterval')

			expect(parsed.render).toHaveProperty('groupByTimeOfDay')
			expect(parsed.render).toHaveProperty('maxNestingDepth')
		})

		it('validates JSON content structure', () => {
			const content = generateConfigContent('json')
			const parsed = JSON.parse(content)

			// Check required top-level fields
			expect(parsed).toHaveProperty('version')
			expect(parsed).toHaveProperty('attachmentRoots')
			expect(parsed).toHaveProperty('gemini')
			expect(parsed).toHaveProperty('enrichment')
			expect(parsed).toHaveProperty('render')
		})

		it('generated config has correct default values', () => {
			const content = generateConfigContent('yaml')
			const parsed = yaml.load(content) as any

			expect(parsed.version).toBe('1.0')
			expect(parsed.gemini.model).toBe('gemini-1.5-pro')
			expect(parsed.gemini.rateLimitDelay).toBe(1000)
			expect(parsed.gemini.maxRetries).toBe(3)
			expect(parsed.enrichment.checkpointInterval).toBe(100)
			expect(parsed.render.maxNestingDepth).toBe(10)
		})

		it('generated config uses environment variable placeholders', () => {
			const yamlContent = generateConfigContent('yaml')
			const yamlParsed = yaml.load(yamlContent) as any

			expect(yamlParsed.gemini.apiKey).toBe('${GEMINI_API_KEY}')

			const jsonContent = generateConfigContent('json')
			const jsonParsed = JSON.parse(jsonContent)

			expect(jsonParsed.gemini.apiKey).toBe('${GEMINI_API_KEY}')
		})

		it('validates numeric constraints', () => {
			const content = generateConfigContent('yaml')
			const parsed = yaml.load(content) as any

			// rateLimitDelay should be >= 0
			expect(parsed.gemini.rateLimitDelay).toBeGreaterThanOrEqual(0)

			// maxRetries should be 0-10
			expect(parsed.gemini.maxRetries).toBeGreaterThanOrEqual(0)
			expect(parsed.gemini.maxRetries).toBeLessThanOrEqual(10)

			// checkpointInterval should be 1-10000
			expect(parsed.enrichment.checkpointInterval).toBeGreaterThanOrEqual(1)
			expect(parsed.enrichment.checkpointInterval).toBeLessThanOrEqual(10000)

			// maxNestingDepth should be 1-100
			expect(parsed.render.maxNestingDepth).toBeGreaterThanOrEqual(1)
			expect(parsed.render.maxNestingDepth).toBeLessThanOrEqual(100)
		})

		it('validates boolean flags have correct types', () => {
			const content = generateConfigContent('yaml')
			const parsed = yaml.load(content) as any

			expect(typeof parsed.enrichment.enableVisionAnalysis).toBe('boolean')
			expect(typeof parsed.enrichment.enableAudioTranscription).toBe('boolean')
			expect(typeof parsed.enrichment.enableLinkEnrichment).toBe('boolean')
			expect(typeof parsed.enrichment.forceRefresh).toBe('boolean')

			expect(typeof parsed.render.groupByTimeOfDay).toBe('boolean')
			expect(typeof parsed.render.renderRepliesAsNested).toBe('boolean')
			expect(typeof parsed.render.renderTapbacksAsEmoji).toBe('boolean')
		})
	})

	// ============================================================================
	// Integration Tests
	// ============================================================================

	describe('Integration: Full workflow', () => {
		it('generates YAML file that can be loaded and validated', async () => {
			// Generate file
			const generateResult = await generateConfigFile({
				filePath: testYamlPath,
				format: 'yaml',
			})
			expect(generateResult.success).toBe(true)

			// Read and parse
			const content = await readFile(testYamlPath, 'utf-8')
			const parsed = yaml.load(content)

			// Should be parseable
			expect(parsed).toBeDefined()
			expect(parsed).toBeTypeOf('object')
		})

		it('generates JSON file that can be loaded and validated', async () => {
			// Generate file
			const generateResult = await generateConfigFile({
				filePath: testJsonPath,
				format: 'json',
			})
			expect(generateResult.success).toBe(true)

			// Read and parse
			const content = await readFile(testJsonPath, 'utf-8')
			const parsed = JSON.parse(content)

			// Should be parseable
			expect(parsed).toBeDefined()
			expect(parsed).toBeTypeOf('object')
		})

		it('prevents accidental overwrites by default', async () => {
			// Create file
			await generateConfigFile({ filePath: testYamlPath, format: 'yaml' })

			// Try to overwrite without force
			const result = await generateConfigFile({
				filePath: testYamlPath,
				format: 'yaml',
			})

			expect(result.success).toBe(false)
		})

		it('allows intentional overwrites with --force', async () => {
			// Create file
			await generateConfigFile({ filePath: testYamlPath, format: 'yaml' })

			// Overwrite with force
			const result = await generateConfigFile({
				filePath: testYamlPath,
				format: 'yaml',
				force: true,
			})

			expect(result.success).toBe(true)
		})
	})
})
