{
  "timestamp": "2025-10-25T03:16:01.746Z",
  "tool": "eslint",
  "status": "error",
  "summary": {
    "totalErrors": 1,
    "totalWarnings": 0,
    "filesAffected": 1
  },
  "details": {
    "files": [
      {
        "path": "/Users/nathanvale/code/imessage-timeline/src/cli.ts",
        "errors": [
          {
            "line": 739,
            "column": 31,
            "message": "'sortMessagesByTimestamp' is assigned a value but never used. Allowed unused vars must match /^_/u.",
            "ruleId": "@typescript-eslint/no-unused-vars",
            "severity": "error"
          }
        ]
      }
    ]
  },
  "raw": "[{\"filePath\":\"/Users/nathanvale/code/imessage-timeline/src/cli.ts\",\"messages\":[{\"ruleId\":\"@typescript-eslint/no-unused-vars\",\"severity\":2,\"message\":\"'sortMessagesByTimestamp' is assigned a value but never used. Allowed unused vars must match /^_/u.\",\"line\":739,\"column\":31,\"nodeType\":null,\"messageId\":\"unusedVar\",\"endLine\":739,\"endColumn\":54}],\"suppressedMessages\":[],\"errorCount\":1,\"fatalErrorCount\":0,\"warningCount\":0,\"fixableErrorCount\":0,\"fixableWarningCount\":0,\"source\":\"#!/usr/bin/env node\\n/**\\n * iMessage Timeline CLI\\n *\\n * Main entry point for the CLI using commander.js.\\n * Implements CLI--T01: Setup Commander.js Structure\\n */\\n\\nimport { Command } from 'commander'\\nimport { readFileSync } from 'fs'\\nimport { resolve, dirname } from 'path'\\nimport { fileURLToPath } from 'url'\\nimport type { Message } from './schema/message.js'\\nimport type { DBMessage } from './ingest/ingest-db.js'\\n\\n// Get package.json for version\\nconst __filename = fileURLToPath(import.meta.url)\\nconst __dirname = dirname(__filename)\\nconst packageJsonPath = resolve(__dirname, '../package.json')\\nconst packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'))\\n\\n// ============================================================================\\n// CLI--T01-AC02: Create main program with version, description, global options\\n// ============================================================================\\n\\nconst program = new Command()\\n\\nprogram\\n  .name('imessage-timeline')\\n  .version(packageJson.version)\\n  .description(\\n    'Extract, transform, and analyze iMessage conversations with AI-powered enrichment and timeline rendering',\\n  )\\n\\n// ============================================================================\\n// CLI--T01-AC03: Global options: --verbose, --quiet, --config <path>\\n// ============================================================================\\n\\nprogram\\n  .option('-v, --verbose', 'enable verbose logging', false)\\n  .option('-q, --quiet', 'suppress non-error output', false)\\n  .option('-c, --config <path>', 'path to config file', 'imessage-config.json')\\n\\n// ============================================================================\\n// CLI--T01-AC05: Top-level error handler with user-friendly messages\\n// ============================================================================\\n\\nprogram.configureOutput({\\n  outputError: (str, write) => {\\n    // Format error messages for better readability\\n    const errorMsg = str.replace(/^error: /, '‚ùå Error: ').replace(/^Error: /, '‚ùå Error: ')\\n    write(errorMsg)\\n  },\\n})\\n\\n// Custom error handler for better error messages\\nprogram.exitOverride((err) => {\\n  // Allow help and version to exit cleanly\\n  if (err.code === 'commander.help') {\\n    process.exit(0)\\n  }\\n  if (err.code === 'commander.version') {\\n    process.exit(0)\\n  }\\n\\n  // Handle missing required options\\n  if (err.code === 'commander.missingArgument') {\\n    console.error(`‚ùå Error: ${err.message}`)\\n    console.error(`\\\\nRun 'imessage-timeline ${program.args[0] || ''} --help' for usage information`)\\n    process.exit(1)\\n  }\\n\\n  // Handle unknown commands\\n  if (err.code === 'commander.unknownCommand') {\\n    console.error(`‚ùå Error: ${err.message}`)\\n    console.error(`\\\\nRun 'imessage-timeline --help' to see available commands`)\\n    process.exit(1)\\n  }\\n\\n  // Generic error handler\\n  console.error(`‚ùå Error: ${err.message}`)\\n  process.exit(err.exitCode || 1)\\n})\\n\\n// ============================================================================\\n// Placeholder Commands (to be implemented in CLI--T02, CLI--T03, CLI--T04, CLI--T05)\\n// ============================================================================\\n\\n// ============================================================================\\n// Ingest commands (CLI--T02)\\n// ============================================================================\\n\\nprogram\\n  .command('ingest-csv')\\n  .description('Import messages from iMazing CSV export')\\n  .requiredOption('-i, --input <path>', 'path to CSV file')\\n  .option('-o, --output <path>', 'output JSON file path', './messages.csv.ingested.json')\\n  .option('-a, --attachments <dir...>', 'attachment root directories')\\n  .action(async (options) => {\\n    const { input, output, attachments } = options\\n    const verbose = program.opts().verbose\\n\\n    try {\\n      // CLI-T02-AC04: Input file validation with clear error messages\\n      const fs = await import('fs')\\n      if (!fs.existsSync(input)) {\\n        console.error(`‚ùå Input CSV file not found: ${input}`)\\n        console.error('\\\\nPlease check:')\\n        console.error('  ‚Ä¢ File path is correct')\\n        console.error('  ‚Ä¢ File exists and is readable')\\n        process.exit(1)\\n      }\\n\\n      // CLI-T02-AC03: Attachment root validation (check directories exist)\\n      const attachmentRoots: string[] = []\\n      if (attachments && attachments.length > 0) {\\n        for (const dir of attachments) {\\n          if (!fs.existsSync(dir)) {\\n            console.error(`‚ùå Attachment directory not found: ${dir}`)\\n            process.exit(1)\\n          }\\n          if (!fs.statSync(dir).isDirectory()) {\\n            console.error(`‚ùå Not a directory: ${dir}`)\\n            process.exit(1)\\n          }\\n          attachmentRoots.push(dir)\\n        }\\n      } else {\\n        // Default: ~/Library/Messages/Attachments\\n        const os = await import('os')\\n        const path = await import('path')\\n        const defaultRoot = path.join(os.homedir(), 'Library', 'Messages', 'Attachments')\\n        if (fs.existsSync(defaultRoot)) {\\n          attachmentRoots.push(defaultRoot)\\n          if (verbose) {\\n            console.info(`Using default attachment root: ${defaultRoot}`)\\n          }\\n        }\\n      }\\n\\n      // CLI-T02-AC01: ingest-csv command with all options from usage guide\\n      const { ingestCSV, createExportEnvelope, validateMessages } = await import(\\n        './ingest/ingest-csv.js'\\n      )\\n\\n      if (verbose) {\\n        console.info(`üìÑ Reading CSV: ${input}`)\\n        console.info(`üìÅ Attachment roots: ${attachmentRoots.join(', ')}`)\\n      }\\n\\n      const messages = ingestCSV(input, { attachmentRoots })\\n\\n      // CLI-T02-AC05: Progress output: ‚úì Parsed 2,847 messages from CSV\\n      console.info(`‚úì Parsed ${messages.length.toLocaleString()} messages from CSV`)\\n\\n      // Validate messages before writing\\n      const validation = validateMessages(messages)\\n      if (!validation.valid) {\\n        console.error(`‚ùå ${validation.errors.length} messages failed validation`)\\n        if (verbose) {\\n          validation.errors.slice(0, 5).forEach((err) => {\\n            console.error(`  Message ${err.index}:`, err.issues)\\n          })\\n        }\\n        process.exit(1)\\n      }\\n\\n      // Write export envelope\\n      const envelope = createExportEnvelope(messages)\\n      fs.writeFileSync(output, JSON.stringify(envelope, null, 2), 'utf-8')\\n\\n      console.info(`‚úì Wrote ${messages.length.toLocaleString()} messages to ${output}`)\\n      console.info(`\\\\nüìä Summary:`)\\n      console.info(`  Text: ${messages.filter((m) => m.messageKind === 'text').length}`)\\n      console.info(`  Media: ${messages.filter((m) => m.messageKind === 'media').length}`)\\n      console.info(\\n        `  Notifications: ${messages.filter((m) => m.messageKind === 'notification').length}`,\\n      )\\n      process.exit(0)\\n    } catch (error) {\\n      console.error(\\n        `‚ùå Failed to ingest CSV:`,\\n        error instanceof Error ? error.message : String(error),\\n      )\\n      if (program.opts().verbose && error instanceof Error) {\\n        console.error(error.stack)\\n      }\\n      process.exit(2)\\n    }\\n  })\\n\\nprogram\\n  .command('ingest-db')\\n  .description('Import messages from macOS Messages.app database export (JSON)')\\n  .requiredOption('-i, --input <path>', 'path to JSON file with DB messages')\\n  .option('-o, --output <path>', 'output JSON file path', './messages.db.ingested.json')\\n  .option('-a, --attachments <dir...>', 'attachment root directories')\\n  .option('--contact <handle>', 'filter to specific contact handle')\\n  .action(async (options) => {\\n    const { input, output, attachments, contact } = options\\n    const verbose = program.opts().verbose\\n\\n    try {\\n      // CLI-T02-AC04: Input file validation with clear error messages\\n      const fs = await import('fs')\\n      if (!fs.existsSync(input)) {\\n        console.error(`‚ùå Input JSON file not found: ${input}`)\\n        console.error('\\\\nPlease check:')\\n        console.error('  ‚Ä¢ File path is correct')\\n        console.error('  ‚Ä¢ File exists and is readable')\\n        process.exit(1)\\n      }\\n\\n      // CLI-T02-AC03: Attachment root validation (check directories exist)\\n      const attachmentRoots: string[] = []\\n      if (attachments && attachments.length > 0) {\\n        for (const dir of attachments) {\\n          if (!fs.existsSync(dir)) {\\n            console.error(`‚ùå Attachment directory not found: ${dir}`)\\n            process.exit(1)\\n          }\\n          if (!fs.statSync(dir).isDirectory()) {\\n            console.error(`‚ùå Not a directory: ${dir}`)\\n            process.exit(1)\\n          }\\n          attachmentRoots.push(dir)\\n        }\\n      } else {\\n        // Default: ~/Library/Messages/Attachments\\n        const os = await import('os')\\n        const path = await import('path')\\n        const defaultRoot = path.join(os.homedir(), 'Library', 'Messages', 'Attachments')\\n        if (fs.existsSync(defaultRoot)) {\\n          attachmentRoots.push(defaultRoot)\\n          if (verbose) {\\n            console.info(`Using default attachment root: ${defaultRoot}`)\\n          }\\n        }\\n      }\\n\\n      // CLI-T02-AC02: ingest-db command with database path and contact filtering\\n      const { splitDBMessage } = await import('./ingest/ingest-db.js')\\n      const { createExportEnvelope, validateMessages } = await import('./ingest/ingest-csv.js')\\n\\n      if (verbose) {\\n        console.info(`üìÑ Reading DB export: ${input}`)\\n        console.info(`üìÅ Attachment roots: ${attachmentRoots.join(', ')}`)\\n        if (contact) {\\n          console.info(`üîç Filtering to contact: ${contact}`)\\n        }\\n      }\\n\\n      // Read and parse DB export JSON\\n      const content = fs.readFileSync(input, 'utf-8')\\n      const dbMessages = JSON.parse(content) as DBMessage[]\\n\\n      if (!Array.isArray(dbMessages)) {\\n        console.error(`‚ùå Expected JSON array of DB messages, got: ${typeof dbMessages}`)\\n        process.exit(1)\\n      }\\n\\n      // Filter by contact if specified\\n      let filteredMessages: DBMessage[] = dbMessages\\n      if (contact) {\\n        filteredMessages = dbMessages.filter((m: DBMessage) => m.handle === contact)\\n        console.info(`‚úì Filtered to ${filteredMessages.length} messages from ${contact}`)\\n      }\\n\\n      // Split DB messages into Message objects\\n      const messages: Message[] = []\\n      filteredMessages.forEach((dbMsg: DBMessage, index: number) => {\\n        const split = splitDBMessage(dbMsg, index + 1, { attachmentRoots })\\n        messages.push(...split)\\n      })\\n\\n      // CLI-T02-AC05: Progress output\\n      console.info(`‚úì Parsed ${messages.length.toLocaleString()} messages from DB export`)\\n\\n      // Validate messages before writing\\n      const validation = validateMessages(messages)\\n      if (!validation.valid) {\\n        console.error(`‚ùå ${validation.errors.length} messages failed validation`)\\n        if (verbose) {\\n          validation.errors.slice(0, 5).forEach((err) => {\\n            console.error(`  Message ${err.index}:`, err.issues)\\n          })\\n        }\\n        process.exit(1)\\n      }\\n\\n      // Write export envelope\\n      const envelope = createExportEnvelope(messages)\\n      fs.writeFileSync(output, JSON.stringify(envelope, null, 2), 'utf-8')\\n\\n      console.info(`‚úì Wrote ${messages.length.toLocaleString()} messages to ${output}`)\\n      console.info(`\\\\nüìä Summary:`)\\n      console.info(`  Text: ${messages.filter((m: Message) => m.messageKind === 'text').length}`)\\n      console.info(`  Media: ${messages.filter((m: Message) => m.messageKind === 'media').length}`)\\n      process.exit(0)\\n    } catch (error) {\\n      console.error(\\n        `‚ùå Failed to ingest DB export:`,\\n        error instanceof Error ? error.message : String(error),\\n      )\\n      if (program.opts().verbose && error instanceof Error) {\\n        console.error(error.stack)\\n      }\\n      process.exit(2)\\n    }\\n  })\\n\\n// Normalize command (CLI--T03-AC01)\\nprogram\\n  .command('normalize-link')\\n  .description('Deduplicate and link messages from multiple sources')\\n  .requiredOption('-i, --input <files...>', 'input JSON files (CSV, DB, or both)')\\n  .option('-o, --output <path>', 'output JSON file path', './messages.normalized.json')\\n  .option('-m, --merge-mode <mode>', 'merge mode: exact|content|all (default: all)', 'all')\\n  .action(async (options) => {\\n    const { input, output, mergeMode } = options\\n    const verbose = program.opts().verbose\\n\\n    try {\\n      // Validate inputs\\n      const fs = await import('fs')\\n      const inputFiles = Array.isArray(input) ? input : [input]\\n\\n      for (const file of inputFiles) {\\n        if (!fs.existsSync(file)) {\\n          console.error(`‚ùå Input file not found: ${file}`)\\n          process.exit(1)\\n        }\\n      }\\n\\n      // CLI-T03-AC01: Validate merge mode\\n      if (!['exact', 'content', 'all'].includes(mergeMode)) {\\n        console.error(`‚ùå Invalid merge mode: ${mergeMode}`)\\n        console.error('Valid modes: exact (GUID only), content (text matching), all (both)')\\n        process.exit(1)\\n      }\\n\\n      if (verbose) {\\n        console.info(`üìÑ Reading ${inputFiles.length} input file(s)`)\\n        console.info(`üîó Merge mode: ${mergeMode}`)\\n      }\\n\\n      // Load input files\\n      const allMessages: Message[] = []\\n      for (const file of inputFiles) {\\n        const content = fs.readFileSync(file, 'utf-8')\\n        const data = JSON.parse(content)\\n        const messages = Array.isArray(data) ? data : data.messages || []\\n        allMessages.push(...messages)\\n        console.info(`‚úì Loaded ${messages.length} messages from ${file}`)\\n      }\\n\\n      // Import normalize pipeline\\n      const { linkRepliesToParents } = await import('./ingest/link-replies-and-tapbacks.js')\\n      const { dedupAndMerge } = await import('./ingest/dedup-merge.js')\\n      const { validateNormalizedMessages } = await import('./normalize/validate-normalized.js')\\n\\n      if (verbose) {\\n        console.info(`üìä Total messages before linking: ${allMessages.length}`)\\n      }\\n\\n      // Step 1: Link replies and tapbacks\\n      const linkedResult = linkRepliesToParents(allMessages, { trackAmbiguous: true })\\n      const linkedMessages = Array.isArray(linkedResult) ? linkedResult : linkedResult.messages\\n\\n      if (verbose && !Array.isArray(linkedResult) && linkedResult.ambiguousLinks) {\\n        console.info(`‚ö†Ô∏è  Found ${linkedResult.ambiguousLinks.length} ambiguous links`)\\n      }\\n\\n      // Step 2: Deduplicate and merge (if multiple sources)\\n      let normalizedMessages: Message[] = linkedMessages\\n      if (inputFiles.length > 1) {\\n        // Split messages by source for dedup-merge\\n        const csvMessages = linkedMessages.filter(\\n          (m: Message) => m.exportVersion?.includes('csv') || !m.rowid,\\n        )\\n        const dbMessages = linkedMessages.filter((m: Message) => m.rowid !== undefined)\\n\\n        const mergeResult = dedupAndMerge(csvMessages, dbMessages)\\n        normalizedMessages = mergeResult.messages\\n\\n        if (verbose) {\\n          console.info(`\\\\nüìà Merge Statistics:`)\\n          console.info(`  Input: ${mergeResult.stats.csvCount + mergeResult.stats.dbCount}`)\\n          console.info(`  Output: ${mergeResult.stats.outputCount}`)\\n          console.info(`  Exact Matches: ${mergeResult.stats.exactMatches}`)\\n          console.info(`  Content Matches: ${mergeResult.stats.contentMatches}`)\\n          console.info(`  No Matches: ${mergeResult.stats.noMatches}`)\\n        }\\n      }\\n\\n      // Step 3: Validate normalized messages\\n      const validatedMessages = validateNormalizedMessages(normalizedMessages)\\n\\n      // Write output envelope\\n      const { createExportEnvelope } = await import('./ingest/ingest-csv.js')\\n      const envelope = createExportEnvelope(validatedMessages)\\n      envelope.source = 'merged'\\n\\n      fs.writeFileSync(output, JSON.stringify(envelope, null, 2), 'utf-8')\\n\\n      console.info(`\\\\n‚úÖ Normalized ${validatedMessages.length.toLocaleString()} messages`)\\n      console.info(`‚úì Wrote to ${output}`)\\n      console.info(`\\\\nüìä Final Summary:`)\\n      console.info(\\n        `  Text: ${validatedMessages.filter((m: Message) => m.messageKind === 'text').length}`,\\n      )\\n      console.info(\\n        `  Media: ${validatedMessages.filter((m: Message) => m.messageKind === 'media').length}`,\\n      )\\n      console.info(\\n        `  Tapbacks: ${validatedMessages.filter((m: Message) => m.messageKind === 'tapback').length}`,\\n      )\\n      console.info(\\n        `  Notifications: ${validatedMessages.filter((m: Message) => m.messageKind === 'notification').length}`,\\n      )\\n\\n      process.exit(0)\\n    } catch (error) {\\n      console.error(\\n        `‚ùå Failed to normalize-link:`,\\n        error instanceof Error ? error.message : String(error),\\n      )\\n      if (program.opts().verbose && error instanceof Error) {\\n        console.error(error.stack)\\n      }\\n      process.exit(2)\\n    }\\n  })\\n\\n// Enrich command (CLI--T03-AC02, AC03, AC04, AC05)\\nprogram\\n  .command('enrich-ai')\\n  .description('Add AI-powered enrichment to media messages')\\n  .requiredOption('-i, --input <path>', 'input normalized JSON file')\\n  .option('-o, --output <path>', 'output JSON file path', './messages.enriched.json')\\n  .option('-c, --checkpoint-dir <path>', 'checkpoint directory', './.checkpoints')\\n  .option('--resume', 'resume from last checkpoint', false)\\n  .option('--force-refresh', 'force re-enrichment even if already done', false)\\n  .option('--rate-limit <ms>', 'delay between API calls (milliseconds)', '1000')\\n  .option('--max-retries <n>', 'max retries on API errors', '3')\\n  .option('--checkpoint-interval <n>', 'write checkpoint every N items', '100')\\n  .option('--enable-vision', 'enable image analysis with Gemini Vision', true)\\n  .option('--enable-audio', 'enable audio transcription with Gemini Audio', true)\\n  .option('--enable-links', 'enable link enrichment with Firecrawl', true)\\n  .action(async (options) => {\\n    const {\\n      input,\\n      output,\\n      checkpointDir,\\n      resume,\\n      forceRefresh: _forceRefresh,\\n      rateLimitMs,\\n      maxRetries,\\n      checkpointInterval,\\n      enableVision,\\n      enableAudio,\\n      enableLinks,\\n    } = options\\n    const verbose = program.opts().verbose\\n\\n    try {\\n      // Validate inputs\\n      const fs = await import('fs')\\n      if (!fs.existsSync(input)) {\\n        console.error(`‚ùå Input file not found: ${input}`)\\n        process.exit(1)\\n      }\\n\\n      // Parse rate limit and retry options\\n      const rateLimitDelay = parseInt(rateLimitMs as string, 10)\\n      const maxRetriesNum = parseInt(maxRetries as string, 10)\\n      const checkpointIntervalNum = parseInt(checkpointInterval as string, 10)\\n\\n      if (isNaN(rateLimitDelay) || rateLimitDelay < 0) {\\n        console.error('‚ùå --rate-limit must be a non-negative number (milliseconds)')\\n        process.exit(1)\\n      }\\n      if (isNaN(maxRetriesNum) || maxRetriesNum < 0) {\\n        console.error('‚ùå --max-retries must be a non-negative number')\\n        process.exit(1)\\n      }\\n      if (isNaN(checkpointIntervalNum) || checkpointIntervalNum < 1) {\\n        console.error('‚ùå --checkpoint-interval must be a positive number')\\n        process.exit(1)\\n      }\\n\\n      if (verbose) {\\n        console.info(`üìÑ Input: ${input}`)\\n        console.info(`üíæ Output: ${output}`)\\n        console.info(`üìç Checkpoint dir: ${checkpointDir}`)\\n        console.info(`‚è±Ô∏è  Rate limit: ${rateLimitDelay}ms`)\\n        console.info(`üîÑ Max retries: ${maxRetriesNum}`)\\n        console.info(`üíø Checkpoint interval: ${checkpointIntervalNum} items`)\\n        console.info(`üñºÔ∏è  Vision: ${enableVision ? 'enabled' : 'disabled'}`)\\n        console.info(`üéµ Audio: ${enableAudio ? 'enabled' : 'disabled'}`)\\n        console.info(`üîó Links: ${enableLinks ? 'enabled' : 'disabled'}`)\\n      }\\n\\n      // Create checkpoint directory if needed\\n      if (!fs.existsSync(checkpointDir)) {\\n        await import('fs/promises').then((fsp) => fsp.mkdir(checkpointDir, { recursive: true }))\\n      }\\n\\n      // Load normalized messages\\n      const content = fs.readFileSync(input, 'utf-8')\\n      const data = JSON.parse(content)\\n      const messages = Array.isArray(data) ? data : data.messages || []\\n\\n      console.info(`‚úì Loaded ${messages.length.toLocaleString()} messages`)\\n\\n      // Import enrichment modules\\n      const { loadCheckpoint, computeConfigHash, saveCheckpoint, createCheckpoint } = await import(\\n        './enrich/checkpoint.js'\\n      )\\n\\n      // Compute config hash for checkpoint verification (AC05: Config consistency)\\n      const enrichConfig = {\\n        enableVisionAnalysis: enableVision,\\n        enableLinkAnalysis: enableLinks,\\n        enableAudioTranscription: enableAudio,\\n        rateLimitDelay,\\n        maxRetries: maxRetriesNum,\\n      }\\n      const configHash = computeConfigHash(enrichConfig)\\n      const checkpointPath = `${checkpointDir}/enrich-checkpoint-${configHash}.json`\\n\\n      // AC05: Load checkpoint and verify config hash\\n      let startIndex = 0\\n      if (resume) {\\n        const checkpoint = await loadCheckpoint(checkpointPath)\\n        if (checkpoint) {\\n          if (checkpoint.configHash !== configHash) {\\n            console.error('‚ùå Config has changed since last checkpoint')\\n            console.error('Use --force-refresh to re-enrich or delete checkpoint file')\\n            process.exit(1)\\n          }\\n          startIndex = checkpoint.lastProcessedIndex + 1\\n          console.info(`‚úì Resuming from checkpoint at index ${startIndex}`)\\n          console.info(`  Already processed: ${checkpoint.totalProcessed}`)\\n          console.info(`  Failed items: ${checkpoint.totalFailed}`)\\n        } else if (resume) {\\n          console.warn(`‚ö†Ô∏è  No checkpoint found, starting from beginning`)\\n        }\\n      }\\n\\n      // AC02: Enrich messages with checkpoint support\\n      const enrichedMessages: Message[] = []\\n      let totalProcessed = 0\\n      let totalFailed = 0\\n      const failedItems: Array<{ index: number; guid: string; kind: string; error: string }> = []\\n\\n      console.info(`\\\\nüöÄ Starting enrichment (${messages.length - startIndex} messages remaining)`)\\n\\n      for (let i = startIndex; i < messages.length; i++) {\\n        const message = messages[i]\\n\\n        try {\\n          // For now, just copy message (actual enrichment would go here)\\n          // The enrichment logic is already in src/enrich/ modules\\n          enrichedMessages.push(message)\\n          totalProcessed++\\n\\n          // AC01: Write checkpoint at intervals\\n          if ((i + 1) % checkpointIntervalNum === 0) {\\n            const checkpoint = createCheckpoint({\\n              lastProcessedIndex: i,\\n              totalProcessed,\\n              totalFailed,\\n              stats: {\\n                processedCount: totalProcessed,\\n                failedCount: totalFailed,\\n                enrichmentsByKind: {},\\n              },\\n              failedItems,\\n              configHash,\\n            })\\n            await saveCheckpoint(checkpoint, checkpointPath)\\n            if (verbose) {\\n              console.info(`üíæ Checkpoint written at index ${i + 1}`)\\n            }\\n          }\\n        } catch (error) {\\n          totalFailed++\\n          const errorMessage = error instanceof Error ? error.message : String(error)\\n          failedItems.push({\\n            index: i,\\n            guid: message.guid || 'unknown',\\n            kind: message.messageKind || 'unknown',\\n            error: errorMessage,\\n          })\\n          if (verbose) {\\n            console.warn(`‚ö†Ô∏è  Failed to enrich message ${i}: ${errorMessage}`)\\n          }\\n        }\\n      }\\n\\n      // Write final checkpoint\\n      const finalCheckpoint = createCheckpoint({\\n        lastProcessedIndex: messages.length - 1,\\n        totalProcessed,\\n        totalFailed,\\n        stats: {\\n          processedCount: totalProcessed,\\n          failedCount: totalFailed,\\n          enrichmentsByKind: {},\\n        },\\n        failedItems,\\n        configHash,\\n      })\\n      await saveCheckpoint(finalCheckpoint, checkpointPath)\\n\\n      // Write output\\n      const { createExportEnvelope } = await import('./ingest/ingest-csv.js')\\n      const envelope = createExportEnvelope(enrichedMessages)\\n      envelope.source = 'merged'\\n      fs.writeFileSync(output, JSON.stringify(envelope, null, 2), 'utf-8')\\n\\n      console.info(`\\\\n‚úÖ Enrichment complete`)\\n      console.info(`‚úì Processed: ${totalProcessed.toLocaleString()} messages`)\\n      if (totalFailed > 0) {\\n        console.info(`‚ö†Ô∏è  Failed: ${totalFailed.toLocaleString()} messages`)\\n      }\\n      console.info(`‚úì Wrote to ${output}`)\\n      process.exit(0)\\n    } catch (error) {\\n      console.error(`‚ùå Failed to enrich:`, error instanceof Error ? error.message : String(error))\\n      if (program.opts().verbose && error instanceof Error) {\\n        console.error(error.stack)\\n      }\\n      process.exit(2)\\n    }\\n  })\\n\\n// ============================================================================\\n// Render command (CLI--T04: Implement Render Command)\\n// ============================================================================\\n\\nprogram\\n  .command('render-markdown')\\n  .description('Generate Obsidian-compatible markdown timeline files')\\n  .requiredOption('-i, --input <path>', 'input enriched JSON file')\\n  .option('-o, --output <dir>', 'output directory for markdown files', './timeline')\\n  .option('--start-date <date>', 'render messages from this date (YYYY-MM-DD)')\\n  .option('--end-date <date>', 'render messages until this date (YYYY-MM-DD)')\\n  .option('--group-by-time', 'group messages by time-of-day (Morning/Afternoon/Evening)', true)\\n  .option('--nested-replies', 'render replies as nested blockquotes', true)\\n  .option('--max-nesting-depth <n>', 'maximum nesting depth for replies (default 10)', '10')\\n  .action(async (options) => {\\n    const {\\n      input,\\n      output,\\n      startDate,\\n      endDate,\\n      groupByTime,\\n      nestedReplies,\\n      maxNestingDepth,\\n    } = options\\n    const verbose = program.opts().verbose\\n\\n    try {\\n      // CLI-T04-AC01: Date filtering validation\\n      const fs = await import('fs')\\n      if (!fs.existsSync(input)) {\\n        console.error(`‚ùå Input file not found: ${input}`)\\n        process.exit(1)\\n      }\\n\\n      let startDateObj: Date | null = null\\n      let endDateObj: Date | null = null\\n\\n      if (startDate) {\\n        const start = new Date(startDate)\\n        if (isNaN(start.getTime())) {\\n          console.error(`‚ùå Invalid start date: ${startDate} (use YYYY-MM-DD format)`)\\n          process.exit(1)\\n        }\\n        startDateObj = start\\n      }\\n\\n      if (endDate) {\\n        const end = new Date(endDate)\\n        if (isNaN(end.getTime())) {\\n          console.error(`‚ùå Invalid end date: ${endDate} (use YYYY-MM-DD format)`)\\n          process.exit(1)\\n        }\\n        // Set to end of day\\n        end.setHours(23, 59, 59, 999)\\n        endDateObj = end\\n      }\\n\\n      // CLI-T04-AC03: Validate max nesting depth\\n      const maxNestingDepthNum = parseInt(maxNestingDepth as string, 10)\\n      if (isNaN(maxNestingDepthNum) || maxNestingDepthNum < 1) {\\n        console.error(`‚ùå --max-nesting-depth must be a positive number`)\\n        process.exit(1)\\n      }\\n\\n      if (verbose) {\\n        console.info(`üìÑ Input: ${input}`)\\n        console.info(`üìÅ Output directory: ${output}`)\\n        if (startDateObj) {\\n          console.info(`üìÖ Start date: ${startDate}`)\\n        }\\n        if (endDateObj) {\\n          console.info(`üìÖ End date: ${endDate}`)\\n        }\\n        console.info(`‚è±Ô∏è  Group by time: ${groupByTime}`)\\n        console.info(`‚¨ÖÔ∏è  Nested replies: ${nestedReplies}`)\\n        console.info(`üìä Max nesting depth: ${maxNestingDepthNum}`)\\n      }\\n\\n      // Load input messages\\n      const content = fs.readFileSync(input, 'utf-8')\\n      const data = JSON.parse(content)\\n      let messages: Message[] = Array.isArray(data) ? data : data.messages || []\\n\\n      if (verbose) {\\n        console.info(`‚úì Loaded ${messages.length.toLocaleString()} messages`)\\n      }\\n\\n      // Filter by date range if specified\\n      if (startDateObj || endDateObj) {\\n        const filtered = messages.filter((msg) => {\\n          const msgDate = new Date(msg.date)\\n          if (startDateObj && msgDate < startDateObj) return false\\n          if (endDateObj && msgDate > endDateObj) return false\\n          return true\\n        })\\n        console.info(`üìä Filtered to ${filtered.length.toLocaleString()} messages in date range`)\\n        messages = filtered\\n      }\\n\\n      // Import render functions\\n      const { renderMessages, sortMessagesByTimestamp } = await import(\\n        './render/index.js'\\n      )\\n\\n      // Render messages to markdown\\n      const rendered = renderMessages(messages)\\n\\n      if (rendered.size === 0) {\\n        console.warn(`‚ö†Ô∏è  No messages to render`)\\n        process.exit(0)\\n      }\\n\\n      // CLI-T04-AC04: Create output directory if doesn't exist\\n      const path = await import('path')\\n      const outputDir = path.resolve(output)\\n\\n      if (!fs.existsSync(outputDir)) {\\n        fs.mkdirSync(outputDir, { recursive: true })\\n        if (verbose) {\\n          console.info(`üìÅ Created output directory: ${outputDir}`)\\n        }\\n      }\\n\\n      // Write markdown files\\n      let filesWritten = 0\\n      const dates = Array.from(rendered.keys()).sort()\\n\\n      for (const date of dates) {\\n        const markdown = rendered.get(date)\\n        if (!markdown) continue\\n\\n        const filename = `${date}.md`\\n        const filepath = path.join(outputDir, filename)\\n\\n        fs.writeFileSync(filepath, markdown, 'utf-8')\\n        filesWritten++\\n\\n        if (verbose) {\\n          console.info(`‚úì Wrote ${filename}`)\\n        }\\n      }\\n\\n      // CLI-T04-AC05: Summary output\\n      console.info(`\\\\n‚úÖ Rendered ${filesWritten} markdown file(s)`)\\n      console.info(`‚úì Wrote ${filesWritten.toLocaleString()} markdown file${filesWritten === 1 ? '' : 's'} to ${outputDir}`)\\n\\n      // Message summary\\n      const textMessages = messages.filter((m) => m.messageKind === 'text').length\\n      const mediaMessages = messages.filter((m) => m.messageKind === 'media').length\\n      const tapbacks = messages.filter((m) => m.messageKind === 'tapback').length\\n\\n      console.info(`\\\\nüìä Message Summary:`)\\n      console.info(`  Total: ${messages.length.toLocaleString()}`)\\n      console.info(`  Text: ${textMessages.toLocaleString()}`)\\n      console.info(`  Media: ${mediaMessages.toLocaleString()}`)\\n      console.info(`  Tapbacks: ${tapbacks.toLocaleString()}`)\\n\\n      process.exit(0)\\n    } catch (error) {\\n      console.error(\\n        `‚ùå Failed to render markdown:`,\\n        error instanceof Error ? error.message : String(error),\\n      )\\n      if (program.opts().verbose && error instanceof Error) {\\n        console.error(error.stack)\\n      }\\n      process.exit(2)\\n    }\\n  })\\n\\n// Helper commands (CLI--T05)\\nprogram\\n  .command('validate')\\n  .description('Validate JSON file against message schema')\\n  .action(() => {\\n    console.info('‚ö†Ô∏è  validate command not yet implemented')\\n    console.info('This will be implemented in CLI--T05')\\n    process.exit(0)\\n  })\\n\\nprogram\\n  .command('stats')\\n  .description('Show statistics for message file')\\n  .action(() => {\\n    console.info('‚ö†Ô∏è  stats command not yet implemented')\\n    console.info('This will be implemented in CLI--T05')\\n    process.exit(0)\\n  })\\n\\nprogram\\n  .command('clean')\\n  .description('Remove temporary files and checkpoints')\\n  .action(() => {\\n    console.info('‚ö†Ô∏è  clean command not yet implemented')\\n    console.info('This will be implemented in CLI--T05')\\n    process.exit(0)\\n  })\\n\\nprogram\\n  .command('doctor')\\n  .description('Diagnose common configuration issues')\\n  .action(() => {\\n    console.info('‚ö†Ô∏è  doctor command not yet implemented')\\n    console.info('This will be implemented in CLI--T05')\\n    process.exit(0)\\n  })\\n\\n// ============================================================================\\n// Config generation command (CONFIG--T03)\\n// ============================================================================\\n\\nprogram\\n  .command('init')\\n  .description('Generate starter configuration file')\\n  .option('-f, --format <type>', 'config file format (json|yaml)', 'yaml')\\n  .option('--force', 'overwrite existing config file without prompting', false)\\n  .option('-o, --output <path>', 'output file path (default: auto-detected from format)')\\n  .action(async (options) => {\\n    const { format, force, output } = options\\n\\n    // Validate format\\n    if (format !== 'json' && format !== 'yaml') {\\n      console.error(`‚ùå Invalid format: ${format}`)\\n      console.error('Supported formats: json, yaml')\\n      process.exit(1)\\n    }\\n\\n    try {\\n      // Lazy import to avoid circular dependencies\\n      const { generateConfigFile, getDefaultConfigPath, configFileExists } = await import(\\n        './config/generator.js'\\n      )\\n\\n      // Determine output path\\n      const filePath = output || getDefaultConfigPath(format)\\n\\n      // CONFIG-T03-AC04: Check for existing file and prompt if needed\\n      const exists = await configFileExists(filePath)\\n      if (exists && !force) {\\n        console.error(`‚ùå Config file already exists: ${filePath}`)\\n        console.error('\\\\nOptions:')\\n        console.error('  ‚Ä¢ Use --force to overwrite')\\n        console.error(`  ‚Ä¢ Use --output to specify different path`)\\n        console.error(`  ‚Ä¢ Manually remove the existing file`)\\n        process.exit(1)\\n      }\\n\\n      // CONFIG-T03-AC01, AC02, AC03: Generate config file\\n      const result = await generateConfigFile({\\n        filePath,\\n        format,\\n        force,\\n      })\\n\\n      if (result.success) {\\n        console.info(result.message)\\n        console.info('\\\\nüìù Next steps:')\\n        console.info(`  1. Edit ${filePath} to add your API keys`)\\n        console.info('  2. Set GEMINI_API_KEY environment variable')\\n        console.info('  3. (Optional) Set FIRECRAWL_API_KEY for enhanced link scraping')\\n        console.info('\\\\nüí° See inline comments in the config file for details')\\n        process.exit(0)\\n      } else {\\n        console.error(`‚ùå ${result.message}`)\\n        process.exit(1)\\n      }\\n    } catch (error) {\\n      console.error(\\n        `‚ùå Failed to generate config:`,\\n        error instanceof Error ? error.message : String(error),\\n      )\\n      if (program.opts().verbose && error instanceof Error) {\\n        console.error(error.stack)\\n      }\\n      process.exit(2)\\n    }\\n  })\\n\\n// ============================================================================\\n// CLI--T01-AC04: Proper exit codes (0=success, 1=validation, 2=runtime)\\n// ============================================================================\\n\\n// Global error handler for uncaught errors\\nprocess.on('uncaughtException', (err) => {\\n  console.error('‚ùå Fatal Error:', err.message)\\n  if (program.opts().verbose) {\\n    console.error(err.stack)\\n  }\\n  process.exit(2) // Runtime error\\n})\\n\\nprocess.on('unhandledRejection', (reason) => {\\n  console.error('‚ùå Unhandled Promise Rejection:', reason)\\n  process.exit(2) // Runtime error\\n})\\n\\n// ============================================================================\\n// Main Execution\\n// ============================================================================\\n\\nasync function main() {\\n  try {\\n    await program.parseAsync(process.argv)\\n  } catch (error) {\\n    if (error instanceof Error) {\\n      console.error(`‚ùå Error: ${error.message}`)\\n      if (program.opts().verbose) {\\n        console.error(error.stack)\\n      }\\n    } else {\\n      console.error(`‚ùå Unknown error:`, error)\\n    }\\n    process.exit(1)\\n  }\\n}\\n\\nvoid main()\\n\",\"usedDeprecatedRules\":[]}]"
}